#!/usr/bin/env ruby

require 'bundler/setup'
require 'gitomator/util/script_util'
require 'gitomator/context'
require 'gitomator/classroom/auto_marker/maven/auto_marker_config'
require 'gitomator/classroom/auto_marker/maven/auto_marker'
require 'gitomator/classroom/auto_marker/maven/results_collector'


include Gitomator::Classroom::AutoMarker

usage_message  = "Usage: #{File.basename($0)} AUTO-MARKER-CONFIG LOCAL-DIR "
opts = Gitomator::ScriptUtil::DefaultOptionParser.new(usage_message).parse(ARGV)
abort usage_message if ARGV.length != 2

context     = Gitomator::Context.from_file(opts[:context])

config_obj = Gitomator::Util.load_config(ARGV[0])
auto_marker = Maven::AutoMarkerConfig.new(config_obj)
auto_marker.validate()
local_dir   = ARGV[1]


# ==============================================================================

#
# This class is here as an example, it will change between assignments.
#
class CustomResultsCollector < Maven::ResultsCollector


  def initialize(context, auto_marker_config, local_dir)
    super(context, auto_marker_config, local_dir)

    # Process all marks together ...
    after_processing_all_repos do |repo2mark, repo2error|
      logger.info "Writing CSV output to stdout ..."
      puts "repo,mark"
      repo2mark.each {|r,m| puts "#{r},#{m}"}
    end
  end


  def process_repo(repo, index)
    # results is a hash, mapping XML filename to failre and error counts (array of two ints)
    results = super(repo, index)

    logger.info "Create Markdown report for #{repo} based on #{results} ..."

    # Example: Convert the results to a final mark (either 0 or 100) ...
    total_failing_tests = results.map {|_, counts| counts.reduce(:+)}.reduce(:+)
    return total_failing_tests > 0 ? 0 : 100
  end

end



# ==============================================================================


Gitomator::ScriptUtil::run_tasks([
  Maven::AutoMarker.new(context, auto_marker, local_dir),
  CustomResultsCollector.new(context, auto_marker, local_dir)
])
